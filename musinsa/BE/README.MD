# 가격을 인덱스로 설정한 이유

### 가격 필드를 인덱스로 설정하는 경우

1. **빈번한 가격 기반 조회**: 가격을 기준으로 데이터를 자주 조회하거나 정렬할 경우.
2. **가격 필터링**: 가격 범위로 데이터를 자주 필터링할 경우.
3. **성능 최적화 필요**: 가격 기반 쿼리의 성능이 중요한 경우.

### 인덱스 설정 예시

가격을 인덱스로 설정하면 다음과 같은 이점이 있습니다.

- **빠른 조회**: 가격 순서로 정렬된 데이터를 빠르게 조회.
- **효율적 필터링**: 특정 가격 범위 내의 데이터를 빠르게 필터링.

예를 들어, 전자 상거래 사이트에서는 사용자가 가격 순으로 상품을 정렬하거나 특정 가격 범위 내의 상품을 찾을 때 인덱스가 유용합니다.

### 인덱스의 단점

1. **추가 저장 공간 필요**: 인덱스를 저장하기 위한 추가 공간이 필요합니다.
2. **데이터 삽입/수정 시 성능 저하**: 인덱스를 유지 관리하기 위해 삽입, 삭제, 업데이트 작업 시 오버헤드가 발생합니다.

### 인덱스 설정 고려사항

1. **쿼리 패턴 분석**: 주로 사용되는 쿼리를 분석하여 인덱스 설정 여부 결정.
2. **데이터 변경 빈도**: 데이터 변경이 빈번한 경우 인덱스 오버헤드를 고려.
3. **테스트**: 인덱스 설정 전후의 성능을 테스트하여 효과를 검증.

### 결론

가격 필드를 인덱스로 설정하는 것은 가격 기반 조회나 정렬, 필터링이 자주 발생하는 경우에 성능을 최적화할 수 있는 좋은 방법입니다. 하지만 인덱스를 추가할 때는 쿼리 패턴을 분석하고, 데이터베이스 성능을 테스트하여 인덱스가 실제로 성능 개선에 도움이 되는지 확인하는 것이 중요합니다. 인덱스는 필요에 따라 신중하게 추가하는 것이 좋습니다.





### 가격에  BigDecimal 사용이유

### 1. **정확한 소수점 연산**

`BigDecimal`은 소수점 이하의 연산을 정확하게 처리할 수 있습니다. 부동소수점 타입인 `float`나 `double`은 근사값을 저장하므로, 특히 금융 계산에서 부정확한 결과를 초래할 수 있습니다.

예시:

```
java코드 복사System.out.println(0.1 + 0.2); // 0.30000000000000004
System.out.println(new BigDecimal("0.1").add(new BigDecimal("0.2"))); // 0.3
```

### 2. **정확한 값 표현**

`BigDecimal`은 정수부와 소수부를 분리하여 저장하기 때문에, 입력한 값을 정확하게 표현할 수 있습니다. 반면, `float`나 `double`은 내부적으로 2진수로 저장되기 때문에 일부 10진수를 정확하게 표현하지 못할 수 있습니다.

### 3. **금융 계산에 적합**

금융 계산에서는 센트 단위의 작은 오차도 큰 문제가 될 수 있습니다. `BigDecimal`을 사용하면 이러한 오차 없이 정확한 계산이 가능합니다.

### 4. **스케일과 정밀도 제어**

`BigDecimal`은 소수점 이하 자리수를 지정할 수 있는 `scale`과 전체 자리수를 지정할 수 있는 `precision`을 통해 값의 정밀도를 제어할 수 있습니다.

